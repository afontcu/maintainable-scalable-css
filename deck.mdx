export { default as theme } from './theme'
import { FullScreenCode } from 'mdx-deck/layouts'
import { Head } from 'mdx-deck'
import { Appear } from 'mdx-deck'
import { Image } from 'mdx-deck'
import { Invert } from 'mdx-deck/layouts'

<Head>
  <title>Maintainable, scalable CSS?</title>
</Head>


---
According to most neuroscience studies, people's number one fear is **public speaking**.

Number two is **death**.
```notes
Esto significa dos cosas:

1) La primera, que en un entierro la gente prefiere estar en el ataúd que dando el réquiem
2) La segunda, que estoy venciendo a la muerte.

Approaches we took with CSS are still relevant to how we approach design systems with React. Same intent, different implementation.
```
---
# Maintainable, scalable CSS
From the trenches

---
# Adrià Fontcuberta
Software Engineer at Calidae

@afontcu_
---
# Adrià Fontcuberta
Frontend Dev at Calidae

@afontcu_
---
# Adrià Fontcuberta
UI Engineer at Calidae

@afontcu_
---
# Adrià Fontcuberta
Webmaster at Calidae

@afontcu_
---
What happened with CSS?
---
It all started with CSS Zen Garden
```notes
Demostraba que podiamos crear miles de versiones de una misma web sin tocar
una sola linea de HTML. Y eso era bueno. Estabamos "separando responsabilidades"
porque esto es lo que hay que hacer, no? Separar responsabilidades.

HTML = contenido y estructura.

CSS = estilo.
```
---
<Image src='images/css-zen-garden.png' />
---
<Image src='images/css-zen-garden-2.png' />
---
```css
.sidebar .design-selection nav ul li a {
  display: inline;
}
```
```notes
Para hacerlo, evidentmente, necesitamos estilos como este. (explicar-lo).

Vale, perfect, ningun problema. CSS se hace así. Y así lo hicimos
```
---
"The HTML remains the same, the only thing that has changed is the external CSS file. Yes, really!"

"HTML is entirely decoupled from the CSS!"

"This is what CSS should look like! We are using The Cascade™"
```notes
Estabamos escribiendo CSS bien? No se, por el contexto pareciera que sí.

Estabamos escribiendo CSS reaprovechable? Nah. Nuestro CSS dependía al 100%
de nuestro HTML. Si el objetivo era separar responsabilidades, lo estabamos
haciendo mal.
```
---
# Enter Sass
With great power comes great responsibility
---
<Image src='images/nesting-hell.png' />
---
```css
body.product .content-body-wrapper.tabs-block .switch 
.offer  section.accommodation .content-width 
.accommodation .select-accommodation-box .list .map {   
  width: 100%; height: 300px; }

body.product .content-body-wrapper.tabs-block .switch .offer 
section.accommodation .content-width .accommodation 
.select-accommodation-box  .list .list-content .items 
.accommodation-info #formAccomodation 
.accommodation-form .mealplan .select-price input {
  display: inline-block; }
```
---
<Image src='images/inception.png' />
---
Is this really what CSS should look like?
---
LOL no. We sucked at good practices.
---
What do you mean by "good pracites"?
---
## Good ol' principles

Standard good practices from other programming languages

Don't Repeat Yourself (DRY)

Single Responsibility Principle (SRP)

...
---
We didn't quite get them.
---
export default Invert

> The worst part about front-end development was that the other people solving your problems were front-end developers

[Adam Morse](http://mrmrs.cc/writing/2016/03/24/scalable-css/)
---
"Separation of Concerns"
---
```css
body.product .content-body-wrapper.tabs-block .switch 
.offer  section.accommodation .content-width 
.accommodation .select-accommodation-box .list .map {   
  width: 100%; height: 300px; }
```
---
Content-semantic class names is not a good idea.

```notes
Cuando juegas con Legos no piensas "ah, mira una pieza que forma parte de la
pared de la habitación que estoy construyendo".

Piensas: "ah mira, una 2x2 gris claro". Puedes hacer lo que quieras con ella.

No puedes reutilizar el propósito de una pieza si este propósito está ligado
al contenido. 
```
---
<Image src="images/remove-the-product.png" />
---
```jsx
<div class="remove-modal">
  <h1>Remove the product</h1>
  <div>
    <img src="" alt="" />
    <p>This action cannot be undone.</p>
  </div>
  <div>
    <button class="remove">Yes</button>
    <button>Cancel</button>
  </div>
</div>
```
---
```scss
.remove-modal {
  > h1 { ... }
  > div {
      img { ... }
      p { ... }
    }
  > div {
    > button {
      &.remove { ... }
    }
  }
}
```

```notes
.remove-modal?

"Separation of Concerns"? Nuestro CSS está totalmente ligado a nuestro HTML.
No puedes editar uno sin editar el otro.
```
---
<Image src="images/2-modals.png" />

```notes
Ahora que?

1. Cosas a sobreescribir: en este caso no, pero es sencillo imaginar un modal
con un footer un poco más alto, de un color distinto, o una cabecera con una
imagen. Quién sabe.

2. Duplicar estilos. Aunque solo sea añadiendo los nuevos selectores con los 
viejos (usando una coma), al final estamos duplicando esos estilos en varios 
selectors. Muy bien el "don't repeat yourself".
```
---
what if
---
```jsx
<div class="modal">
  <h1 class="modal-title">...</h1>
  <div class="modal-body">
    <img class="modal-icon" />
    <p class="modal-message">...</p>
  </div>
  <div class="modal-buttons">
    <button class="btn primary">Yes</buttom>
    <button class="btn">Cancel</buttom>
  </div>
</div>
```

```notes
DRY? Bueno, ahora nos repetimos en el HTML. Va a haber tantas clases ".modal"
como modals en la aplicación.

Llegamos a la conclusión que en alguna parte vas a acabar repitiéndote, quieras
o no. Pero como queremos conseguir algo reusable, lo ideal seria repetirse en
HTML, y así poder reaprovechar el CSS en diferentes proyectos.
```
---
visual CSS > semantic CSS
---
what if
---
<Image src="images/modal-alert.png" />
---
```scss
.modal-messages {
  .modal-icon { ... }
  .modal-message { ... }
}

.alert-content {
  .alert-img { ... }
  .alert-text { ... }
}
```

```notes
Volvemos a estar en las mismas. Es el mismo elemento? Podemos seguir reduciento
nuestros bloques?

Recordemos SRP: nuestros elementos, modulos, clases, whatever, deberían hacer
una cosa, solamente una, y hacerla bien. Qué tal esto?
```
---
```scss
.text-with-icon {}
```
---
```scss
.icon-text {}
```

```notes
No estabamos inventando nada nuevo. Esto ya existia.

Tanto el concepto de "CSS visual" como la metáfora concreta de "icon-text" o 
cómo quieras llamarlo.
```
---
export default Invert

> The **media object** is an image to the left, with descriptive content to the right.

[Nicole Sullivan](http://www.stubbornella.org/content/2010/06/25/the-media-object-saves-hundreds-of-lines-of-code/)
---
<img src="images/media-object.png" />
---
## Goal achieved

Our building blocks (css classes) were now reusable across projects.

_(remember: digital agency context)_
---
we were not building pages anymore.

we were building components of a system.
---
from styling pages to creating design systems.
---
# Design systems
* Rules
* Constraints
* Principles
---
**Rules**: Spacing values must be proportional.

**Constraints**: Only 5 spacing values available.

**Principles**: Spacing should be consistent across elements.
---
```scss
$global-baseline: 6px;
```

```scss
$unit-factor-tiny:   1;
$unit-factor-small:  2;
$unit-factor:        4;
$unit-factor-large:  8;
$unit-factor-huge:  16;
```
---
results in

```scss
$global-spacing-unit-tiny;  // 6px
$global-spacing-unit-small; // 12px
$global-spacing-unit;       // 24px
$global-spacing-unit-large; // 48px
$global-spacing-unit-huge;  // 96px
```

```notes
Funcionaria exactamente igual usando javascript.

Tendríamos nuestro theme.js o lo que sea, y allí crearíamos los valores
válidos para nuestro sistema.
```
---
Styles based on systems became harmonious.
---
```scss
$global-font-sizes: (
  h1: 32px,
  h2: 28px,
  h3: 24px,
  h4: 20px,
  h5: 18px,
  h6: 16px
);
```
---
we had the right pieces.

we still needed conventions, structure and organization.
---
# ITCSS + BEM
Inverted Triangle CSS (by [Harry Roberts](https://www.creativebloq.com/web-design/manage-large-css-projects-itcss-101517528))

Block Element Modifier (by Yandex)
---
## Why "inverted triangle"?

from global to local.

from generic to concrete.

from low specificity to high specificity.
---
```bash
scss/
  1-Settings/
  2-Tools/
  3-Base/
  4-Generic/
  5-Objects/
  6-Components/
  7-Utilities/
```
---
/scss/1-Settings/_settings.font-sizing.scss

```scss
$global-font-sizes: (
  h1: 32px,
  h2: 28px,
  h3: 24px,
  h4: 20px,
  h5: 18px,
  h6: 16px
);
```
---
## Why BEM?

Because we need to reach an agreement. How to name things?

How to identify components and objects?

A Media Object has several parts. Children. How do we identify them?
---
```css
.block {}

.block__element {}

.block--modifier {}

.block__element--modifier {}
```
---
```css
.person {}

.person__eyes {}

.person--tall {}

.person__eyes--blue {}
```
---
## Namespaces

Objects (.o-)

Components (.c-)

Utilities (.u-)
---
/scss/5-Objects/_objects.media.scss

```scss
.o-media { display: flex; align-items: flex-start; }

.o-media__body { flex: 1; }

.o-media__image { margin-right: $global-spacing-unit; }

.o-media--large { margin-right: $global-spacing-unit-large; }
```
---
what if
---
```scss
.o-media--large {
  margin-right: $global-spacing-unit-large; }

.c-list_item--large {
  margin-right: $global-spacing-unit-large; }

.c-header--spaced {
  margin-right: $global-spacing-unit-large; }
```
---
```scss
.u-margin-right-large {
  margin-right: $global-spacing-unit-large;
}
```
---
Dead by modifiers
---
```jsx
<nav class="c-nav c-nav--large c-nav--primary-color c-nav--boxed
            c-nav--rounded c-nav--full-width">
    <ul>
      <li class="c-nav__item c-nav__item--boxed c-nav__item--black
                 c-nav__item--padded-bottom c-nav__item--huge">
      </li>
    </ul>
</nav>
```

```notes
what if we start out writing utility classes, and create components when needed?
```
---
# Utility-first CSS

```notes
"first" significa que empezamos usando los bloques "Legos" más pequeños.

Cuando vemos un patrón que se repite, ese es el momento de crear un componente.

Es exactamente lo mismo que hacemos en React, Vue, Angular, o cualquier framework
o lenguaje para construir aplicaciones.

Así evitamos hacer abstracciones prematuras.
```
---
export default Invert

> The best way of writing great CSS is **to avoid writing CSS**.

Me
---
create a lot of small, reusable, focused CSS classes, and use them to build your UI.
---
```jsx
<nav class="c-nav c-nav--boxed u-margin-right-large u-color-primary
            u-radius-circle u-width-100">
    <ul>
      <li class="c-nav__item c-nav__item--boxed u-color-black
                 u-padding-bottom-small u-margin-left-huge">
      </li>
    </ul>
</nav>
```
---
It is possible to build a new component without wiring a single line of CSS.
---
```jsx
<nav class="u-padding u-margin-bottom-tiny u-text-dark u-flex
            u-background-primary u-text-dark u-flex-center">
  ...
</nav>
```
```notes
Tiene sentido crear el componente "MainNav"? Es la navegación principal. Si tienes
suficiente con las utilidades, para que crear una abstracción de algo que no 
vas a reutilizar?

Este es el beneficio principal de utility-first. Abstracciones cuando las
necesitas, no antes.
```
---